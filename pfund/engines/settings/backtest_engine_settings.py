from decimal import Decimal

from pydantic import Field, field_validator

from pfund.typing import Currency, ProductName
from pfund.enums import TradingVenue
from pfund.engines.settings.base_engine_settings import BaseEngineSettings


class BacktestEngineSettings(BaseEngineSettings):
    # If not provided, will use the default initial balances in SimulatedBroker
    initial_balances: dict[TradingVenue | str, dict[Currency, Decimal]] = Field(default_factory=dict)
    initial_positions: dict[TradingVenue | str, dict[ProductName, Decimal]] = Field(default_factory=dict)
    
    # FIXME: these 3 params require "mtflow" installed
    retention_period: int = Field(default=7, ge=1, description='the retention period for backtests in days')
    commit_to_git: bool = Field(default=False)
    save_backtests: bool = Field(default=True)

    preload_min_data: bool = Field(
        default=True,
        description='''
        if True, pre-loads each component's `min_data` rows during materialization for event-driven backtesting,
        so strategies start with enough data to produce signals immediately.
        Set to False to simulate every bar from the start, including the warm-up phase.
        '''
    )
    reuse_signals: bool = Field(
        default=False,
        description='''
        if True, reuses signals from dumped signal_df in _next() instead of recalculating the signals.
        This will make event-driven backtesting a LOT faster but inconsistent with live trading.
        '''
    )
    assert_signals: bool = Field(
        default=True,
        description='''
        if True, asserts signals generated by event-driven backtesting and vectorized backtesting are the same,
        by collecting results during event-driven backtesting.
        '''
    )

    @field_validator('initial_balances', 'initial_positions', mode='before')
    @classmethod
    def _validate_initial_balances_and_positions(cls, v: dict[TradingVenue | str, dict[str, Decimal]]):
        return {
            TradingVenue[trading_venue.upper()]: {
                ccy_or_pdt.upper(): Decimal(amount) for ccy_or_pdt, amount in bal_or_pos.items()
            }
            for trading_venue, bal_or_pos in v.items()
        }
