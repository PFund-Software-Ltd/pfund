from __future__ import annotations
from typing import TYPE_CHECKING, overload
if TYPE_CHECKING:
    import torch
    import pandas as pd
    import polars as pl
    from pfeed.typing import tDATA_SOURCE, tSTORAGE
    from pfund.typing import ModelT, DataConfigDict, tTRADING_VENUE
    from pfund.datas.data_base import BaseData
    from pfund.datas.data_time_based import TimeBasedData
    from pfund.engines.backtest_engine import BacktestEngine

import numpy as np

from pfund import cprint
from pfund.strategies.strategy_base import BaseStrategy
from pfund.models.model_base import BaseModel
from pfund.enums import BacktestMode


def vectorized(func):
    def wrapper(*args, **kwargs):
        self: BacktestMixin | BaseStrategy | BaseModel = args[0]
        engine: BacktestEngine = self._engine
        if engine.mode == BacktestMode.vectorized:
            return func(*args, **kwargs)
        else:
            raise Exception(f"{func.__name__}() is only available in vectorized backtesting.")
    return wrapper


def event_driven(func):
    def wrapper(*args, **kwargs):
        self: BacktestMixin | BaseStrategy | BaseModel = args[0]
        engine: BacktestEngine = self._engine
        if engine.mode == BacktestMode.event_driven:
            return func(*args, **kwargs)
        else:
            raise Exception(f"{func.__name__}() is only available in event driven backtesting.")
    return wrapper


class BacktestMixin:
    # NOTE: custom __post_init__ is called in MetaStrategy/MetaModel
    # used to avoid confusing __init__ pattern in MetaStrategy/MetaModel
    # end result: only the __init__ of a normal class (real strategy/model class, not _BacktestStrategy/_BacktestModel) is called in the end
    def __post_init__(self: BacktestMixin | BaseStrategy | BaseModel, *args, **kwargs):
        # NOTE: signal_df = INDEX columns + signals generated by the current strategy/model
        self._signal_df = None
        self._signal_list = []
        self._signal_list_num = 0
            
        self._is_dummy_strategy = False
        self._is_signal_df_required = self._check_if_signal_df_required()
        self._is_append_to_df = self._check_if_append_to_df()
    
    def on_stop(self: BaseStrategy | BaseModel):
        super().on_stop()
        if self._engine.mode == BacktestMode.event_driven and self._engine._assert_signals and self._has_signal_df():
            self._assert_consistent_signals()
            
    def _next(self: BacktestMixin | BaseStrategy | BaseModel, data: BaseData) -> torch.Tensor | np.ndarray:
        if not self._is_signal_df_required:
            new_pred = super()._next(data)
        else:
            new_pred = self._signal_list[self._signal_list_num]
            self._signal_list_num += 1
        return new_pred
    
    def set_flags(self: BacktestMixin | BaseStrategy | BaseModel, is_dummy_strategy: bool):
        # case1: strategy is a dummy strategy
        # case2: model is using a dummy strategy as its only consumer
        self._is_dummy_strategy = is_dummy_strategy
        self._is_signal_df_required = self._check_if_signal_df_required()
        self._is_append_to_df = self._check_if_append_to_df()
    
    def _append_to_df(self: BacktestMixin | BaseStrategy | BaseModel, data: BaseData, **kwargs):
        if self._is_append_to_df:
            return self.data_tool.append_to_df(data, self.predictions, **kwargs)
    
    def _check_if_signal_df_required(self: BacktestMixin | BaseStrategy | BaseModel) -> bool:
        if self._is_dummy_strategy:
            return False
        elif self._engine.mode == BacktestMode.vectorized:
            return True
        elif self._engine.mode == BacktestMode.event_driven:
            return self._engine._use_signal_df
    
    def _check_if_append_to_df(self: BacktestMixin | BaseStrategy | BaseModel):
        if isinstance(self, BaseStrategy):
            return not self._is_signal_df_required and not self._is_dummy_strategy
        else:
            return not self._is_signal_df_required
    
    def _has_signal_df(self: BacktestMixin | BaseStrategy | BaseModel):
        return ( isinstance(self, BaseStrategy) and self.is_sub_strategy() ) or isinstance(self, BaseModel)
    
    def signalize(
        self: BacktestMixin | BaseStrategy | BaseModel, 
        X: pd.DataFrame | pl.LazyFrame,
        pred_y: torch.Tensor | np.ndarray,
    ) -> pd.DataFrame | pl.LazyFrame:
        try:
            import torch
        except ImportError:
            torch = None
        if torch is not None and isinstance(pred_y, torch.Tensor):
            pred_y = pred_y.detach().numpy() if pred_y.requires_grad else pred_y.numpy()
        signal_cols = self.get_signal_cols()
        signal_df: pd.DataFrame | pl.LazyFrame = self.data_tool.signalize(X, pred_y, columns=signal_cols)
        return signal_df
    
    def _set_signal_df(self: BacktestMixin | BaseStrategy | BaseModel, signal_df: pd.DataFrame | pl.LazyFrame):
        assert signal_df.shape[0] == self.df.shape[0], f"{signal_df.shape[0]=} != {self.df.shape[0]=}"
        nan_columns = self.data_tool.get_nan_columns(signal_df)
        assert not nan_columns, f"{self.name} signal_df has all NaN values in columns: {nan_columns}"
        self._signal_list = signal_df.drop(columns=self.INDEX).to_numpy().tolist()
        self._signal_df = signal_df
    
    @event_driven
    def _assert_consistent_signals(self: BacktestMixin | BaseStrategy | BaseModel):
        '''Asserts consistent signals from vectorized and event-driven backtesting, triggered in event-driven backtesting'''
        from pfeed.enums import DataTool

        self.logger.debug(f"asserting {self.name}'s signals...")
        
        # since current strategy/model's signal_df is its consumer's prediction column
        # get the signal_df from the consumer
        consumer_df = self._consumers[0].df

        # load the signal_df dumped from vectorized backtesting
        self._is_signal_df_required = True
        self.load()

        if self.data_tool.name == DataTool.pandas:
            event_driven_signal_df = consumer_df[self.INDEX + self._signal_cols]
            # NOTE: since the loaded signal_df might have a few more rows than event_driven_signal_df
            # because the last bar is not pushed in event-driven backtesting.
            # truncate the signal_df to the same length as event_driven_signal_df
            vectorized_signal_df = self._signal_df.iloc[:len(event_driven_signal_df)]
        elif self.data_tool.name == DataTool.polars:
            event_driven_signal_df = consumer_df.select(self.INDEX + self._signal_cols)
            vectorized_signal_df = self._signal_df.slice(0, len(event_driven_signal_df))
        # TODO
        else:
            raise NotImplementedError
        self.data_tool.assert_frame_equal(vectorized_signal_df, event_driven_signal_df)

    def _add_raw_df(self: BacktestMixin | BaseStrategy | BaseModel, data, df):
        return self.data_tool.add_raw_df(data, df)
    
    def _prepare_df(self: BacktestMixin | BaseStrategy | BaseModel):
        if self._is_dummy_strategy and isinstance(self, BaseStrategy):
            return
        ts_col_type = 'timestamp' if self._engine.mode == BacktestMode.event_driven else 'datetime'
        self.data_tool.prepare_df(ts_col_type=ts_col_type)
        if self._is_signal_df_required:
            self._merge_signal_dfs_with_df()
    
    def _merge_signal_dfs_with_df(self: BacktestMixin | BaseStrategy | BaseModel):
        '''Merge df with signal dfs from all listeners (strategies/models)'''
        if isinstance(self, BaseStrategy):
            if signal_dfs := [strategy._signal_df for strategy in self.strategies.values()]:
                self.data_tool.merge_signal_dfs_with_df(signal_dfs)
        if signal_dfs := [model._signal_df for model in self.models.values()]:
            self.data_tool.merge_signal_dfs_with_df(signal_dfs)
    
    def clear_dfs(self: BacktestMixin | BaseStrategy | BaseModel):
        assert self._engine.mode == BacktestMode.event_driven
        if not self._is_signal_df_required:
            self._data_tool.clear_df()
        if isinstance(self, BaseStrategy):
            for strategy in self.strategies.values():
                strategy.clear_dfs()
        for model in self.models.values():
            model.clear_dfs()
    
    def add_data(
        self: BaseStrategy | BaseModel, 
        trading_venue: tTRADING_VENUE, 
        product: str,
        resolution: str,
        data_source: tDATA_SOURCE | None=None,
        from_storage: tSTORAGE | None=None,
        data_config: DataConfigDict | None=None,
        **product_specs
    ) -> list[BaseData]:
        datas: list[TimeBasedData] = super().add_data(trading_venue, product, resolution, data_source=data_source, from_storage=from_storage, data_config=data_config, **product_specs)
        use_tick_or_quote = any(data.resolution.is_tick() or data.resolution.is_quote() for data in datas)
        if use_tick_or_quote:
            cprint('WARNING: tick data and quote data will be ignored in backtesting', style='bold red')
        return datas
    
    def _add_consumers_datas_if_no_data(self: BacktestMixin | BaseStrategy | BaseModel) -> list[BaseData]:
        '''Add consumers' raw dfs if no datas'''
        datas = super()._add_consumers_datas_if_no_data()
        for data in datas:
            for consumer in self._consumers:
                dtl = consumer.dtl
                if dtl.has_raw_df(data):
                    df = dtl.get_raw_df(data)
                    self._add_raw_df(data, df)
                    break
        return datas
    
    @overload
    def dump(self: BacktestMixin | BaseStrategy | BaseModel, signal_df: pd.DataFrame | pl.LazyFrame): ...
        
    def add_model(
        self: BaseStrategy | BaseModel, 
        model: ModelT, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> BacktestMixin | ModelT:
        from pfund.models.model_backtest import BacktestModel
        name = name or model.get_default_name()
        model = BacktestModel(type(model), model.ml_model, *model._args, **model._kwargs)
        return super().add_model(
            model, 
            name=name, 
            min_data=min_data, 
            max_data=max_data, 
            group_data=group_data,
            signal_cols=signal_cols,
        )
