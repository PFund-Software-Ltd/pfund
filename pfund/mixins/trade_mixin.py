from __future__ import annotations
from typing import TYPE_CHECKING, overload, Literal
if TYPE_CHECKING:
    import torch
    import numpy as np
    import pandas as pd
    import polars as pl
    from pfund.types.core import tModel, tIndicator, tFeature
    from pfund.types.common_literals import tSUPPORTED_TRADING_VENUES, tSUPPORTED_BROKERS, tSUPPORTED_CRYPTO_EXCHANGES
    from pfund.datas.data_base import BaseData
    from pfund.brokers import BaseBroker, CryptoBroker, IBBroker
    from pfund.products import BaseProduct, CryptoProduct, IBProduct
    from pfund.strategies.strategy_base import BaseStrategy
    from pfund.models.model_base import BaseModel
    from pfund.datas.data_quote import QuoteData
    from pfund.datas.data_tick import TickData
    from pfund.datas.data_bar import BarData

import sys
import time
import datetime
from pathlib import Path

from pfund.const.common import SUPPORTED_CRYPTO_EXCHANGES
from pfund.datas.resolution import Resolution
from pfund.utils.utils import load_yaml_file, convert_ts_to_dt
from pfund.plogging import create_dynamic_logger


class TradeMixin:
    _file_path: Path | None = None  # Get the file path where the strategy was defined
    config = {}

    @classmethod
    def load_config(cls, config: dict | None=None):
        if config:
            cls.config = config
        elif cls._file_path:
            for file_name in ['config.yml', 'config.yaml']:
                if config := load_yaml_file(cls._file_path.parent / file_name):
                    cls.config = config
                    break
    
    def load_params(self, params: dict | None=None):
        if params:
            self.params = params
        elif self._file_path:
            for file_name in ['params.yml', 'params.yaml']:
                if params := load_yaml_file(self._file_path.parent / file_name):
                    self.params = params
                    break
    
    def __new__(cls, *args, **kwargs):
        if not cls._file_path:
            module = sys.modules[cls.__module__]
            if file_path := getattr(module, '__file__', None):
                cls._file_path = Path(file_path)
                cls.load_config()
        return super().__new__(cls)
    
    def get_df(
        self, 
        start_idx: int=0, 
        end_idx: int | None=None, 
        product: str | None=None, 
        resolution: str | None=None, 
        copy: bool=True
    ) -> pd.DataFrame | pl.LazyFrame | None:
        return self._data_tool.get_df(
            start_idx=start_idx, 
            end_idx=end_idx, 
            product=product,
            resolution=resolution,
            copy=copy
        )
        
    # NOTE: df = X + predictions generated by other strategies/models
    @property
    def df(self):
        return self.get_df(copy=False)

    @property
    def dtl(self):
        return self._data_tool
    data_tool = dtl

    @property
    def signals(self):
        return self._signals
    
    @property
    def features(self):
        return {mdl: model for mdl, model in self.models.items() if model.is_feature()}
    
    @property
    def extractions(self):
        return {pred_name: prediction for pred_name, prediction in self.predictions.items() if self.models[pred_name.split('-')[0]].is_feature()}
    
    @property
    def indicators(self):
        return {mdl: model for mdl, model in self.models.items() if model.is_indicator()}
    
    @property
    def indications(self):
        return {pred_name: prediction for pred_name, prediction in self.predictions.items() if self.models[pred_name.split('-')[0]].is_indicator()}

    @property
    def INDEX(self):
        return self.dtl.INDEX
    
    @property
    def GROUP(self):
        return self.dtl.GROUP
    
    @property
    def tname(self):
        '''Add type to the name if it is not already there.'''
        if self.type not in self.name:
            return f"{self.name}_{self.type}"
        else:
            return self.name
    
    @staticmethod
    def dt(ts: float):
        return convert_ts_to_dt(ts)
    
    @staticmethod
    def now():
        return datetime.datetime.now(tz=datetime.timezone.utc)
    
    @staticmethod
    def get_delay(ts: float) -> float:
        return time.time() - ts
    
    def is_running(self):
        return self._is_running
    
    def create_logger(self):
        self.logger = create_dynamic_logger(self.name, self.type)
    
    def _prepare_df(self):
        return self.dtl.prepare_df(ts_col_type='timestamp')
    
    def _append_to_df(self, data: BaseData, **kwargs):
        return self.dtl.append_to_df(data, self.predictions, **kwargs)
    
    def get_default_name(self):
        return self.__class__.__name__
    
    def get_default_signal_cols(self, num_cols: int) -> list[str]:
        if num_cols == 1:
            columns = [self.name]
        else:
            columns = [f'{self.name}-{i}' for i in range(num_cols)]
        return columns
   
    def get_signal_cols(self) -> list[str]:
        return self._signal_cols
    
    def set_signal_cols(self, columns: list[str]):
        self._signal_cols = [f'{self.name}-{col}' if not col.startswith(self.name) else col for col in columns]
        self._num_signal_cols = len(columns)
        
    def _add_consumer(self, consumer: BaseStrategy | BaseModel):
        if consumer not in self._consumers:
            self._consumers.append(consumer)
            
    def _add_listener(self, listener: BaseStrategy | BaseModel, listener_key: BaseData):
        if listener not in self._listeners[listener_key]:
            self._listeners[listener_key].append(listener)
    
    def _remove_listener(self, listener: BaseStrategy | BaseModel, listener_key: BaseData):
        if listener in self._listeners[listener_key]:
            self._listeners[listener_key].remove(listener)
    
    def _derive_bkr_from_trading_venue(self, trading_venue: tSUPPORTED_TRADING_VENUES) -> tSUPPORTED_BROKERS:
        trading_venue = trading_venue.upper()
        return 'CRYPTO' if trading_venue in SUPPORTED_CRYPTO_EXCHANGES else trading_venue
    
    @overload
    def get_broker(self, bkr: Literal['CRYPTO']) -> CryptoBroker: ...
        
    @overload
    def get_broker(self, bkr: Literal['IB']) -> IBBroker: ...
    
    def get_broker(self, bkr: tSUPPORTED_BROKERS) -> BaseBroker:
        return self.engine.get_broker(bkr)
    
    def get_broker_from_trading_venue(self, trading_venue: tSUPPORTED_TRADING_VENUES) -> BaseBroker:
        bkr = self._derive_bkr_from_trading_venue(trading_venue)
        return self.get_broker(bkr)
    
    def get_brokers(self) -> list[BaseBroker]:
        return list(self.engine.brokers.values())
    
    @overload
    def get_product(self, trading_venue: tSUPPORTED_CRYPTO_EXCHANGES, pdt: str, exch: str='') -> CryptoProduct | None: ...
        
    @overload
    def get_product(self, trading_venue: Literal['IB'], pdt: str, exch: str='') -> IBProduct | None: ...
    
    def get_product(self, trading_venue: tSUPPORTED_TRADING_VENUES, pdt: str, exch: str='') -> BaseProduct | None:
        broker = self.get_broker_from_trading_venue(trading_venue)
        if broker.name == 'CRYPTO':
            exch = trading_venue
            product: BaseProduct | None = broker.get_product(exch, pdt)
        else:
            product: BaseProduct | None = broker.get_product(pdt, exch=exch)
        if product and product not in self.datas:
            self.logger.warning(f"{self.name} is getting '{product}' that is not in its datas")
        return product
    
    def get_products(self) -> list[BaseProduct]:
        return list(self.datas.keys())
        
    # TODO
    def add_custom_data(self):
        pass

    def get_datas(self) -> list[BaseData]:
        datas = []
        for product in self.datas:
            datas.extend(list(self.datas[product].values()))
        return datas
    
    def set_data(self, product: BaseProduct, resolution: str | Resolution, data: BaseData):
        if isinstance(resolution, Resolution):
            resolution = repr(resolution)
        self.datas[product][resolution] = data

    def get_data(self, product: BaseProduct, *, resolution: str) -> BaseData | None:
        return self.datas[product].get(resolution, None)
    
    def _add_consumers_datas_if_no_data(self) -> list[BaseData]:
        if self.datas or not self._consumers:
            return []
        self.logger.info(f"No data for {self.name}, adding datas from consumers {[consumer.name for consumer in self._consumers]}")
        datas = []
        for consumer in self._consumers:
            for data in consumer.get_datas():
                self.set_data(data.product, data.resolution, data)
                consumer._add_listener(listener=self, listener_key=data)
                if data not in datas:
                    datas.append(data)
        return datas
    
    def get_model(self, name: str) -> BaseModel:
        return self.models[name]
    
    def add_model(
        self, 
        model: tModel, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> tModel:
        '''Adds a model to the current model.
        Args:
            min_data (int): Minimum number of data points required for the model to make a prediction.
            max_data (int | None): Maximum number of data points required for the model to make a prediction.
            - If None: max_data is set to min_data.
            - If value=-1: include all data
            
            group_data (bool): Determines how `min_data` and `max_data` are applied to the whole df:
            - If True: `min_data` and `max_data` apply to each group=(product, resolution).
            e.g. if `min_data=2`, at least two data points are required for each group=(product, resolution).
            - If False: `min_data` and `max_data` apply to the entire dataset, not segregated by product or resolution.
            e.g. if `min_data=2`, at least two data points are required for the whole dataset.
            
            signal_cols: signal columns, if not provided, it will be derived in predict()
        '''
        Model = model.get_model_type_of_ml_model()
        assert isinstance(model, Model), \
            f"{model.type} '{model.__class__.__name__}' is not an instance of {Model.__name__}. Please create your {model.type} using 'class {model.__class__.__name__}({Model.__name__})'"
        if name:
            model.set_name(name)
        model.create_logger()
        if min_data:
            model.set_min_data(min_data)
        if max_data:
            model.set_max_data(max_data)
        model.set_group_data(group_data)
        if signal_cols:
            model.set_signal_cols(signal_cols)
        mdl = model.name
        if mdl in self.models:
            return self.models[mdl]
        model._add_consumer(self)
        self.models[mdl] = model
        self.logger.debug(f"added {model.tname}")
        return model
    
    def remove_model(self, name: str):
        if name in self.models:
            del self.models[name]
            self.logger.debug(f"removed '{name}'")
        else:
            self.logger.error(f"'{name}' cannot be found, failed to remove")
    
    def add_feature(
        self, 
        feature: tFeature, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> tFeature:
        return self.add_model(
            feature, 
            name=name, 
            min_data=min_data, 
            max_data=max_data, 
            group_data=group_data,
            signal_cols=signal_cols,
        )
    
    def remove_feature(self, name: str):
        self.remove_model(name)
    
    def add_indicator(
        self, 
        indicator: tIndicator, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> tIndicator:
        return self.add_model(
            indicator, 
            name=name, 
            min_data=min_data, 
            max_data=max_data, 
            group_data=group_data,
            signal_cols=signal_cols,
        )
    
    def remove_indicator(self, name: str):
        self.remove_model(name)
        
    def update_quote(self, data: QuoteData, **kwargs):
        product, bids, asks, ts = data.product, data.bids, data.asks, data.ts
        for listener in self._listeners[data]:
            listener.update_quote(data, **kwargs)
            self.update_predictions(data, listener)
        self._append_to_df(data, **kwargs)
        self.on_quote(product, bids, asks, ts, **kwargs)

    def update_tick(self, data: TickData, **kwargs):
        product, px, qty, ts = data.product, data.px, data.qty, data.ts
        for listener in self._listeners[data]:
            listener.update_tick(data, **kwargs)
            self.update_predictions(data, listener)
        self._append_to_df(data, **kwargs)
        self.on_tick(product, px, qty, ts, **kwargs)
    
    def update_bar(self, data: BarData, **kwargs):
        product, bar, ts = data.product, data.bar, data.bar.end_ts
        for listener in self._listeners[data]:
            # NOTE: listener could be a strategy or a model
            listener.update_bar(data, **kwargs)
            self.update_predictions(data, listener)
        self._append_to_df(data, **kwargs)
        self.on_bar(product, bar, ts, **kwargs)

    def update_predictions(self, data: BaseData, listener: BaseStrategy | BaseModel):
        pred_y: torch.Tensor | np.ndarray | None = listener._next(data)
        if pred_y is not None:
            signal_cols = listener.get_signal_cols()
            for i, col in enumerate(signal_cols):
                self.predictions[col] = pred_y[i]
                
    def _start_models(self):
        for model in self.models.values():
            model.start()
    
    
    '''
    ************************************************
    Custom Functions
    Users can customize these functions in their strategies/models.
    ************************************************
    '''
    def add_datas(self):
        pass
    
    def add_models(self):
        pass

    def add_features(self):
        pass
    
    def add_indicators(self):
        pass
    
    def on_start(self):
        pass
    
    def on_stop(self):
        pass
    
    
    '''
    ************************************************
    Sugar Functions
    ************************************************
    '''
    def get_second_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}s')
    
    def get_minute_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}m')
    
    def get_hour_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}h')
    
    def get_day_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}d')
    
    def get_week_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}w')
    
    def get_month_bar(self, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}M')