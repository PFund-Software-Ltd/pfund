from __future__ import annotations
from typing import TYPE_CHECKING, overload, Literal
if TYPE_CHECKING:
    import torch
    import numpy as np
    import pandas as pd
    import polars as pl
    from pfeed.typing import GenericFrame, tDATA_SOURCE
    from pfund.data_tools.dataset import Dataset
    from pfund.typing import ModelT, IndicatorT, FeatureT
    from pfund.typing import tTRADING_VENUE, tBROKER, tCRYPTO_EXCHANGE
    from pfund.typing import DataConfigDict, StorageConfigDict
    from pfund.datas.data_base import BaseData
    from pfund.datas.data_time_based import TimeBasedData
    from pfund.brokers.broker_base import BaseBroker
    from pfund.brokers.broker_crypto import CryptoBroker
    from pfund.brokers.ib.broker_ib import IBBroker
    from pfund.products.product_base import BaseProduct
    from pfund.products.product_ib import IBProduct
    from pfund.data_tools.data_tool_base import BaseDataTool
    from pfund.strategies.strategy_base import BaseStrategy
    from pfund.models.model_base import BaseModel
    from pfund.datas import QuoteData, TickData, BarData

import sys
import time
import datetime
from pathlib import Path

from pfund.enums import CryptoExchange, Broker
from pfund.datas.resolution import Resolution
from pfund.utils.utils import load_yaml_file, convert_ts_to_dt
from pfund.plogging import create_dynamic_logger
from pfund.datas.data_config import DataConfig
from pfund.datas.storage_config import StorageConfig


class TradeMixin:
    _file_path: Path | None = None  # Get the file path where the strategy was defined
    config = {}

    @classmethod
    def load_config(cls, config: dict | None=None):
        if config:
            cls.config = config
        elif cls._file_path:
            for file_name in ['config.yml', 'config.yaml']:
                if config := load_yaml_file(cls._file_path.parent / file_name):
                    cls.config = config
                    break
    
    def load_params(self: BaseStrategy | BaseModel, params: dict | None=None):
        if params:
            self.params = params
        elif self._file_path:
            for file_name in ['params.yml', 'params.yaml']:
                if params := load_yaml_file(self._file_path.parent / file_name):
                    self.params = params
                    break
    
    def __new__(cls, *args, **kwargs):
        if not cls._file_path:
            module = sys.modules[cls.__module__]
            if file_path := getattr(module, '__file__', None):
                cls._file_path = Path(file_path)
                cls.load_config()
        return super().__new__(cls)
    
    def get_df(
        self: BaseStrategy | BaseModel, 
        start_idx: int=0, 
        end_idx: int | None=None, 
        product: str | None=None, 
        resolution: str | None=None, 
        copy: bool=True
    ) -> pd.DataFrame | pl.LazyFrame | None:
        return self.data_tool.get_df(
            start_idx=start_idx, 
            end_idx=end_idx, 
            product=product,
            resolution=resolution,
            copy=copy
        )
    
    def _set_resolution(self, resolution: str):
        if not self._resolution:
            self._resolution = Resolution(resolution)
        else:
            raise ValueError(f"{self.name} already has a resolution {self._resolution}, cannot set to {resolution}")
        
    @property
    def resolution(self) -> Resolution | None:
        return self._resolution
    
    @property
    def datas(self: BaseStrategy | BaseModel):
        return self._datas
    
    @property
    def dataset(self: BaseStrategy | BaseModel) -> Dataset:
        return self.data_tool.dataset
    
    @property
    def train_period(self: BaseStrategy | BaseModel) -> tuple[datetime.date, datetime.date]:
        return self.dataset.train_period
    training_period = train_period

    @property
    def val_period(self: BaseStrategy | BaseModel) -> tuple[datetime.date, datetime.date]:
        return self.dataset.val_period
    validation_period = val_period
    
    @property
    def test_period(self: BaseStrategy | BaseModel) -> tuple[datetime.date, datetime.date]:
        return self.dataset.test_period
    testing_period = test_period
    
    @property
    def train_set(self: BaseStrategy | BaseModel) -> GenericFrame:
        return self.data_tool.train_set
    training_set = train_set
    
    @property
    def val_set(self: BaseStrategy | BaseModel) -> GenericFrame:
        return self.data_tool.val_set
    validation_set = val_set
    
    @property
    def test_set(self: BaseStrategy | BaseModel) -> GenericFrame:
        return self.data_tool.test_set
    testing_set = test_set
        
    # NOTE: df = X + predictions generated by other strategies/models
    @property
    def df(self: BaseStrategy | BaseModel):
        return self.get_df(copy=False)

    @property
    def data_tool(self: BaseStrategy | BaseModel) -> BaseDataTool:
        return self._engine._data_tool
    dtl = data_tool

    @property
    def signals(self: BaseStrategy | BaseModel):
        return self._signals
    
    @property
    def features(self: BaseStrategy | BaseModel):
        return {mdl: model for mdl, model in self.models.items() if model.is_feature()}
    
    @property
    def extractions(self: BaseStrategy | BaseModel):
        return {pred_name: prediction for pred_name, prediction in self.predictions.items() if self.models[pred_name.split('-')[0]].is_feature()}
    
    @property
    def indicators(self: BaseStrategy | BaseModel):
        return {mdl: model for mdl, model in self.models.items() if model.is_indicator()}
    
    @property
    def indications(self: BaseStrategy | BaseModel):
        return {pred_name: prediction for pred_name, prediction in self.predictions.items() if self.models[pred_name.split('-')[0]].is_indicator()}

    @property
    def INDEX(self: BaseStrategy | BaseModel):
        return self.data_tool.INDEX
    
    @property
    def GROUP(self: BaseStrategy | BaseModel):
        return self.data_tool.GROUP
    
    @property
    def tname(self: BaseStrategy | BaseModel):
        '''Add type to the name if it is not already there.'''
        if self.type not in self.name:
            return f"{self.name}_{self.type}"
        else:
            return self.name
    
    @staticmethod
    def dt(ts: float) -> datetime.datetime:
        return convert_ts_to_dt(ts)
    
    @staticmethod
    def now() -> datetime.datetime:
        return datetime.datetime.now(tz=datetime.timezone.utc)
    
    @staticmethod
    def get_delay(ts: float) -> float:
        return time.time() - ts
    
    def is_running(self: BaseStrategy | BaseModel):
        return self._is_running
    
    def _create_logger(self: BaseStrategy | BaseModel):
        self.logger = create_dynamic_logger(self.name, self.type)
    
    def _prepare_df(self: BaseStrategy | BaseModel):
        return self.data_tool.prepare_df(ts_col_type='timestamp')
    
    def _append_to_df(self: BaseStrategy | BaseModel, data: BaseData, **extra_data):
        return self.data_tool.append_to_df(data, self.predictions, **extra_data)
    
    def get_default_name(self: BaseStrategy | BaseModel):
        return self.__class__.__name__
    
    def _set_name(self, name: str):
        self.name = name
    
    def get_default_signal_cols(self: BaseStrategy | BaseModel, num_cols: int) -> list[str]:
        if num_cols == 1:
            columns = [self.name]
        else:
            columns = [f'{self.name}-{i}' for i in range(num_cols)]
        return columns
   
    def get_signal_cols(self: BaseStrategy | BaseModel) -> list[str]:
        return self._signal_cols
    
    def set_signal_cols(self: BaseStrategy | BaseModel, columns: list[str]):
        self._signal_cols = [f'{self.name}-{col}' if not col.startswith(self.name) else col for col in columns]
        self._num_signal_cols = len(columns)
        
    def _set_consumer(self: BaseStrategy | BaseModel, consumer: BaseStrategy | BaseModel):
        if not self._consumer:
            self._consumer = consumer
        else:
            raise ValueError(f"{self.name} already has a consumer {self._consumer.name}")
            
    def _add_listener(self: BaseStrategy | BaseModel, listener: BaseStrategy | BaseModel, data: BaseData):
        if listener not in self._listeners[data]:
            self._listeners[data].append(listener)
    
    def _derive_bkr_from_trading_venue(self: BaseStrategy | BaseModel, trading_venue: tTRADING_VENUE) -> tBROKER:
        trading_venue = trading_venue.upper()
        return 'CRYPTO' if trading_venue in CryptoExchange.__members__ else trading_venue
    
    @overload
    def get_broker(self: BaseStrategy | BaseModel, bkr: Literal['CRYPTO']) -> CryptoBroker: ...
        
    @overload
    def get_broker(self: BaseStrategy | BaseModel, bkr: Literal['IB']) -> IBBroker: ...
    
    def get_broker(self: BaseStrategy | BaseModel, trading_venue_or_broker: tBROKER | tTRADING_VENUE) -> BaseBroker:
        if trading_venue_or_broker in Broker.__members__:
            bkr = trading_venue_or_broker
        else:
            bkr = self._derive_bkr_from_trading_venue(trading_venue_or_broker)
        return self._engine.get_broker(bkr)
    
    def list_brokers(self: BaseStrategy | BaseModel) -> list[BaseBroker]:
        return list(self._engine.brokers.values())
    
    @overload
    def get_product(self: BaseStrategy | BaseModel, trading_venue: tCRYPTO_EXCHANGE, pdt: str, exch: str='') -> BaseProduct | None: ...
        
    @overload
    def get_product(self: BaseStrategy | BaseModel, trading_venue: Literal['IB'], pdt: str, exch: str='') -> IBProduct | None: ...
    
    def get_product(self: BaseStrategy | BaseModel, trading_venue: tTRADING_VENUE, pdt: str, exch: str='') -> BaseProduct | None:
        broker = self.get_broker(trading_venue)
        if broker.name == 'CRYPTO':
            exch = trading_venue
            product: BaseProduct | None = broker.get_product(exch, pdt)
        else:
            product: BaseProduct | None = broker.get_product(pdt, exch=exch)
        if product and product not in self._datas:
            self.logger.warning(f"{self.name} is getting '{product}' that is not in its datas")
        return product
    
    def list_products(self: BaseStrategy | BaseModel) -> list[BaseProduct]:
        return list(self._datas.keys())

    def _parse_data_and_storage_config(
        self: BaseStrategy | BaseModel, 
        trading_venue: tTRADING_VENUE, 
        data_source: tDATA_SOURCE | None,
        data_origin: str,
        data_config: DataConfigDict | DataConfig | None,
        storage_config: StorageConfigDict | StorageConfig | None,
    ) -> tuple[DataConfig, StorageConfig]:
        if isinstance(data_config, DataConfig) and isinstance(storage_config, StorageConfig):
            return data_config, storage_config
        data_config = data_config or {}
        data_config['data_source'] = trading_venue if data_source is None else data_source
        data_config['data_origin'] = data_origin
        data_config['primary_resolution'] = self.resolution
        data_config = DataConfig(**data_config)
        if storage_config:
            storage_config = StorageConfig(**storage_config)
        else:
            global_storage_config = self._engine._storage_config
            storage_config = global_storage_config or StorageConfig()
        # TODO: save data signatures properly, data_signatures should be a set
        self._data_signatures.append({k: v for k, v in locals().items() if k not in ['self', '__class__']})
        return data_config, storage_config
    
    # TODO
    def add_custom_data(self: BaseStrategy | BaseModel):
        raise NotImplementedError

    def list_datas(self: BaseStrategy | BaseModel) -> list[TimeBasedData]:
        datas = []
        for product in self._datas:
            datas.extend(list(self._datas[product].values()))
        return datas
        
    def _add_data(self: BaseStrategy | BaseModel, data: TimeBasedData):
        if data.is_quote():
            self._orderbooks[data.product] = data
        elif data.is_tick():
            self._tradebooks[data.product] = data
        self._datas[data.product][data.resol] = data
    
    def _add_data_to_consumer(
        self: BaseStrategy | BaseModel, 
        trading_venue: tTRADING_VENUE, 
        product: str, 
        data_source: tDATA_SOURCE | None=None,
        data_origin: str='', 
        data_config: DataConfigDict | DataConfig | None=None,
        storage_config: StorageConfigDict | StorageConfig | None=None,
        **product_specs
    ) -> list[TimeBasedData]:
        datas: list[TimeBasedData] = self._consumer.add_data(
            trading_venue, 
            product, 
            data_source=data_source, 
            data_origin=data_origin, 
            data_config=data_config, 
            storage_config=storage_config, 
            **product_specs
        )
        for data in datas:
            self._add_data(data)
            self._consumer._add_listener(self, data)
        return datas
    
    def _add_datas_from_consumer_if_none(self: BaseStrategy | BaseModel) -> list[BaseData]:
        has_no_data = self._consumer and not self._datas
        if not has_no_data:
            return []
        self.logger.info(f"No data for {self.name}, adding datas from consumer {self._consumer.name}")
        datas: list[TimeBasedData] = self._consumer.list_datas()
        for data in datas:
            self._add_data(data)
            self._consumer._add_listener(self, data)
        return datas

    def get_data(self: BaseStrategy | BaseModel, product: BaseProduct, resolution: str | Resolution) -> BaseData | None:
        if isinstance(resolution, str):
            resolution = Resolution(resolution)
        resolution_repr = repr(resolution)
        return self._datas[product].get(resolution_repr, None)
    
    def get_orderbook(self: BaseStrategy | BaseModel, product: BaseProduct) -> BaseData:
        return self._orderbooks[product]
    
    def get_tradebook(self: BaseStrategy | BaseModel, product: BaseProduct) -> BaseData:
        return self._tradebooks[product]
    
    def get_model(self: BaseStrategy | BaseModel, name: str) -> BaseModel:
        return self.models[name]
    
    def add_model(
        self: BaseStrategy | BaseModel, 
        model: ModelT, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> ModelT:
        '''Adds a model to the current model.
        Args:
            min_data (int): Minimum number of data points required for the model to make a prediction.
            max_data (int | None): Maximum number of data points required for the model to make a prediction.
            - If None: max_data is set to min_data.
            - If value=-1: include all data
            
            group_data (bool): Determines how `min_data` and `max_data` are applied to the whole df:
            - If True: `min_data` and `max_data` apply to each group=(product, resolution).
            e.g. if `min_data=2`, at least two data points are required for each group=(product, resolution).
            - If False: `min_data` and `max_data` apply to the entire dataset, not segregated by product or resolution.
            e.g. if `min_data=2`, at least two data points are required for the whole dataset.
            
            signal_cols: signal columns, if not provided, it will be derived in predict()
        '''
        Model = model.get_model_type_of_ml_model()
        assert isinstance(model, Model), \
            f"{model.type} '{model.__class__.__name__}' is not an instance of {Model.__name__}. Please create your {model.type} using 'class {model.__class__.__name__}({Model.__name__})'"
        if name:
            model._set_name(name)
        model._create_logger()
        model._set_consumer(self)
        model._set_resolution(self._consumer.resolution)
        if min_data:
            model.set_min_data(min_data)
        if max_data:
            model.set_max_data(max_data)
        model.set_group_data(group_data)
        if signal_cols:
            model.set_signal_cols(signal_cols)
        mdl = model.name
        if mdl in self.models:
            return self.models[mdl]
        self.models[mdl] = model
        self.logger.debug(f"added {model.tname}")
        return model
    
    def remove_model(self: BaseStrategy | BaseModel, name: str):
        if name in self.models:
            del self.models[name]
            self.logger.debug(f"removed '{name}'")
        else:
            self.logger.error(f"'{name}' cannot be found, failed to remove")
    
    def add_feature(
        self: BaseStrategy | BaseModel, 
        feature: FeatureT, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> FeatureT:
        return self.add_model(
            feature, 
            name=name, 
            min_data=min_data, 
            max_data=max_data, 
            group_data=group_data,
            signal_cols=signal_cols,
        )
    
    def remove_feature(self: BaseStrategy | BaseModel, name: str):
        self.remove_model(name)
    
    def add_indicator(
        self: BaseStrategy | BaseModel, 
        indicator: IndicatorT, 
        name: str='',
        min_data: None | int=None,
        max_data: None | int=None,
        group_data: bool=True,
        signal_cols: list[str] | None=None,
    ) -> IndicatorT:
        return self.add_model(
            indicator, 
            name=name, 
            min_data=min_data, 
            max_data=max_data, 
            group_data=group_data,
            signal_cols=signal_cols,
        )
    
    def remove_indicator(self: BaseStrategy | BaseModel, name: str):
        self.remove_model(name)
        
    def update_quote(self: BaseStrategy | BaseModel, data: QuoteData, **extra_data):
        product, bids, asks, ts = data.product, data.bids, data.asks, data.ts
        for listener in self._listeners[data]:
            listener.update_quote(data, **extra_data)
            self.update_predictions(data, listener)
        self._append_to_df(data, **extra_data)
        self.on_quote(product, bids, asks, ts, **extra_data)

    def update_tick(self: BaseStrategy | BaseModel, data: TickData, **extra_data):
        product, px, qty, ts = data.product, data.px, data.qty, data.ts
        for listener in self._listeners[data]:
            listener.update_tick(data, **extra_data)
            self.update_predictions(data, listener)
        self._append_to_df(data, **extra_data)
        self.on_tick(product, px, qty, ts, **extra_data)
    
    def update_bar(self: BaseStrategy | BaseModel, data: BarData, **extra_data):
        product, bar, ts = data.product, data.bar, data.bar.end_ts
        for listener in self._listeners[data]:
            # NOTE: listener could be a strategy or a model
            listener.update_bar(data, **extra_data)
            self.update_predictions(data, listener)
        self._append_to_df(data, **extra_data)
        self.on_bar(product, bar, ts, **extra_data)

    def update_predictions(self: BaseStrategy | BaseModel, data: BaseData, listener: BaseStrategy | BaseModel):
        pred_y: torch.Tensor | np.ndarray | None = listener._next(data)
        if pred_y is not None:
            signal_cols = listener.get_signal_cols()
            for i, col in enumerate(signal_cols):
                self.predictions[col] = pred_y[i]
                
    def _start_models(self: BaseStrategy | BaseModel):
        for model in self.models.values():
            model.start()
    
    
    '''
    ************************************************
    Custom Functions
    Users can customize these functions in their strategies/models.
    ************************************************
    '''
    def add_datas(self: BaseStrategy | BaseModel):
        pass
    
    def add_models(self: BaseStrategy | BaseModel):
        pass

    def add_features(self: BaseStrategy | BaseModel):
        pass
    
    def add_indicators(self: BaseStrategy | BaseModel):
        pass
    
    def on_start(self: BaseStrategy | BaseModel):
        pass
    
    def on_stop(self: BaseStrategy | BaseModel):
        pass
    
    
    '''
    ************************************************
    Sugar Functions
    ************************************************
    '''
    def get_second_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}s')
    
    def get_minute_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}m')
    
    def get_hour_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}h')
    
    def get_day_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}d')
    
    def get_week_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}w')
    
    def get_month_bar(self: BaseStrategy | BaseModel, product: BaseProduct, period: int) -> BarData | None:
        return self.get_data(product, resolution=f'{period}M')